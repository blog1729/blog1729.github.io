<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Blog1729 - Random Number Generation</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
	  tex2jax: {
	  inlineMath: [ ['$','$'], ["\\(","\\)"] ],
	  displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
	  processEscapes: true
	  },
	  TeX: {
	  Macros: {
	  R: "\\mathbb{R}",
	  C: "\\mathbb{C}"
	  }}	  
	  });
	</script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Blog1729</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Random Number Generation</h1>

            <div class="info">
    Posted on February 18, 2015
    
</div>

<h2 id="random-number-generation">Random number generation</h2>
<p>These methods only generate pseudo-random numbers for trivial reasons. Two desirable property for random numbers is:</p>
<ol style="list-style-type: decimal">
<li>each <span class="math inline">\(U_i\)</span> is uniformly distributed between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>;</li>
<li>the <span class="math inline">\(U_i\)</span>’s are mutually independent.</li>
</ol>
<p>Note that property 1 is a convenient but arbitrary normalization. In layman terms, the value of <span class="math inline">\(U_i\)</span> should not be predictable from <span class="math inline">\(U_1, \cdots, U_{i-1}\)</span>.</p>
<h3 id="linear-congruential-generator">Linear congruential generator</h3>
<p>A linear congruential generator is a recurrence of the form</p>
<p><span class="math display">\[x_{i+1} = ax_i \mod m\]</span></p>
<p><span class="math display">\[u_{i+1} = x_{i+1}/m \]</span></p>
<p>The value of <span class="math inline">\(x_0\)</span> is called seed and <span class="math inline">\(a\)</span>, <span class="math inline">\(m\)</span> are integers. L.C.G. is the most widely used generators.</p>
<p>One can see that the pseudo-random numbers generated by L.C.G. generated has a period of at most <span class="math inline">\(m\)</span>, i.e., repeats. For some choice of <span class="math inline">\(a\)</span> and <span class="math inline">\(m\)</span>, they attain full-period or maximum period and in some other cases, they attain a period smaller than <span class="math inline">\(m-1\)</span>. In general full-period is a desired criteria.</p>
<p>The general form of L.C.G takes the following form <span class="math display">\[x_{i+1} = (ax_i+c) \mod m\]</span> <span class="math display">\[u_{i+1} = x_{i+1}/m \]</span></p>
<p>There are various conditions for which full period can be generated and can be found in the book Art of computer programming, semi numeric algorithms by Donald Knuth. Marsaglia was able to prove that the plot of the <span class="math inline">\(k\)</span>-tuple <span class="math inline">\((u_i,\cdots, u_{i+k})\)</span> will be hyper-planes in <span class="math inline">\(k\)</span>-dimension and was also able to arrive at a closed form for maximum number of hyper-planes; this is known as lattice structure of linear congruential generators. The algorithm for implementing linear congruential generators is easy and therefore skipped.</p>
<h3 id="inverse-transform-method">Inverse transform method</h3>
<p>Suppose we want to generate a sample from a cumulative distribution function <span class="math inline">\(F\)</span>, i.e., we want to generate a random variable <span class="math inline">\(X\)</span> with the property that <span class="math inline">\(P(X\le x) = F(x)\)</span> for all <span class="math inline">\(X\)</span>. The inverse transform method set <span class="math display">\[ X = F^{-1}(U) \quad U \sim \text{Unif}[0,1],\]</span> where <span class="math inline">\(F^{-1}\)</span> is the inverse of <span class="math inline">\(F\)</span> and <span class="math inline">\(\text{Unif}[0,1]\)</span> denotes the uniform distribution on <span class="math inline">\([0,1]\)</span>.</p>
<p>The algorithm for this method is pretty straightforward and hence omitted.</p>
<h4 id="inverse-transform-method-for-discrete-distributions.">Inverse transform method for discrete distributions.</h4>
<p>In case of discrete random variables, evaluation of <span class="math inline">\(F^{-1}\)</span> reduces to a table lookup. Consider a discrete random variable whose possible values <span class="math inline">\(c_1&lt;\cdots c_n\)</span>. Let <span class="math inline">\(p_i\)</span> be the probability attached to <span class="math inline">\(c_i, i= 1,\cdots,n\)</span>, and set <span class="math inline">\(q_0 = 0\)</span>, <span class="math display">\[q_i = \sum\limits_{j=1}^{i} p_j, \quad i,\cdots,n.\]</span> These are the cumulative probabilities associated with <span class="math inline">\(q_i = F(c_i), i = 1,\cdots, n\)</span>. To sample from this distribution,</p>
<ol style="list-style-type: decimal">
<li>generate a uniform <span class="math inline">\(U\)</span>;</li>
<li>find <span class="math inline">\(K\in\{1,\cdots,n\}\)</span> such that <span class="math inline">\(q_{K-1} &lt; U \le q_k\)</span>;</li>
<li>set <span class="math inline">\(X = c_K\)</span>.</li>
</ol>
<p>The second step may be implemented using binary search as <span class="math inline">\(q_k\)</span> is an increasing sequence.</p>
<h3 id="acceptance-rejection-method">Acceptance Rejection method</h3>
<p>Acceptance rejection method is a widely applicable method. The rejection mechanism is designed so that the accepted samples are indeed according to the target distribution.</p>
<p>Suppose that we wish to generate samples from a density <span class="math inline">\(f\)</span> defined on some set <span class="math inline">\(X\)</span>, let <span class="math inline">\(g\)</span> be the density on <span class="math inline">\(X\)</span> from which we know how to generate samples and with the property that <span class="math display">\[f(x) \le c g(x), \text{ for all } x\in X\]</span> for some constant <span class="math inline">\(c\)</span>. In acceptance rejection method we generate a sample <span class="math inline">\(X\)</span> from <span class="math inline">\(G\)</span> and accept the sample with probability <span class="math inline">\(f(X)/cg(X)\)</span>; this can be implemented by sampling <span class="math inline">\(U\)</span> uniformly over <span class="math inline">\((0,1)\)</span> and accepting <span class="math inline">\(X\)</span> if <span class="math inline">\(U\le F(X)/cg(X)\)</span>. If <span class="math inline">\(X\)</span> is rejected, a new sample is sampled from <span class="math inline">\(g\)</span> and the acceptance test is applied again.</p>
<p>Algorithm</p>
<p>{% gist b56a1c8f5d961e98d77e %}</p>
<p>Some typical examples are Beta distribution, normal from double exponential,</p>
<h2 id="normal-random-variables-and-vectors">Normal random variables and vectors</h2>
<p>Suppose we have a sample from <span class="math inline">\(N(0,1)\)</span>, i.e., normal distribution from parameters <span class="math inline">\(\mu = 0\)</span> and <span class="math inline">\(\sigma = 1\)</span>, then from this sample we can generate <span class="math inline">\(N(\mu, \sigma)\)</span> by observing that <span class="math inline">\(\mu + \sigma Z \sim N(\mu, \sigma^2)\)</span>.</p>
<h3 id="box-muller-method">Box-Muller method</h3>
<p>A simple method to generate sample from normal distribution is Box-Muller. The algorithm for this method is given below</p>
<p>{% gist 572520bf1f070295fa85 %}</p>
<h3 id="marsaglia-bray-method">Marsaglia-Bray method</h3>
<p>Marsaglia and Bray developed a modification of the Box-Muller method that reduces computing time by avoiding evaluation of sine and cosine functions. (I’m told that calculation of <span class="math inline">\(log\)</span>, <span class="math inline">\(\sqrt{}\)</span>, requires lesser amount of time than <span class="math inline">\(\sin\)</span> and <span class="math inline">\(\cos\)</span>)</p>
<p>Algorithm</p>
<p>{% gist a1718c75604807350c57 %}</p>
<h2 id="references">References</h2>
<ol style="list-style-type: decimal">
<li>Monte Carlo methods in financial engineering, Paul Glasserman.</li>
</ol>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
