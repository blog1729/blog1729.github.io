<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Blog1729 - Optimal Binary Search Trees</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
	  tex2jax: {
	  inlineMath: [ ['$','$'], ["\\(","\\)"] ],
	  displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
	  processEscapes: true
	  },
	  TeX: {
	  Macros: {
	  R: "\\mathbb{R}",
	  C: "\\mathbb{C}"
	  }}	  
	  });
	</script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Blog1729</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Optimal Binary Search Trees</h1>

            <div class="info">
    Posted on March 19, 2015
    
</div>

<p>We are given a seqence <span class="math inline">\(K = \langle k_1, \cdots, k_n \rangle\)</span> of <span class="math inline">\(n\)</span> distinct keys in sorted order and we wish to build a binary search tree out of these keys. For each key, <span class="math inline">\(k_i\)</span>, we have a probability <span class="math inline">\(p_i\)</span> that the search will be for <span class="math inline">\(k_i\)</span>. So we have the following inequality (we assume that there are searches for members other than that in the given sequence).</p>
<p><span class="math display">\[ \sum p_i \le 1\]</span></p>
<p>The expected cost of a tree <span class="math inline">\(T\)</span> can thus be defined as</p>
<p><span class="math display">\[ E[\text{search cost in } T] = \sum(\text{depth}_T(k_i)+1) + \sum (\text{depth}_T(k_i)+1).\]</span></p>
<p>For a given set of probabilities, we wish to construct a binary search tree whose expected search time is the lowest. We call such a tree as <strong>optimal binary search tree</strong>.</p>
<hr />
<h2 id="recursive-relation-and-dynamic-algorithm">Recursive relation and Dynamic algorithm</h2>
<p>We assume that there are no dummy keys and proceed to form an algorithm. The optimal sub-structure for this problem is sub-trees. Let us use <span class="math inline">\(C[i,j]\)</span> to denote the search time of binary tree consisting of elements <span class="math inline">\(\{i, i+1, \cdots, j\}\)</span>. Then one can easily see that</p>
<p><span class="math display">\[ C[i,j] = \max_{i\le r \le j}\left\{ \sum_{k=i}^{j}{p_k} + C[i,r-1]+ C[r+1, j] \right\}\]</span></p>
<p>Thus, the algorithm is clear, create a two-dimensional array fill the array in a bottom up fashion. It should be noted that the first summation in the recursive relation is constant for <span class="math inline">\(r\)</span> under the given constraint.</p>
<h2 id="complexity">Complexity</h2>
<ul>
<li>The time complexity of the above algorithm is <span class="math inline">\(\Theta (n^3)\)</span>.</li>
<li><strong>Trivia</strong>: There is an advanced algorithm that has complexity <span class="math inline">\(\Theta (n^2)\)</span>.</li>
</ul>
<hr />
<p><strong>Note</strong>:</p>
<ul>
<li>There is no known greedy algorithm for this problem. In particular, the following ones can be easily observed:</li>
<li>The optimal binary search tree <em>need not</em> be a tree with the smallest height.</li>
<li>The optimal binary search tree <em>need not</em> be a tree with such that the node of highest probability occurs at the root.</li>
<li>The optimal binary search tree <em>need not</em> be the tree such that the node with lest probability is the deepest node.</li>
<li>The brute force algorithm takes exponential time (the algorithm that calculate the expected search time of all such binary search trees).</li>
</ul>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
