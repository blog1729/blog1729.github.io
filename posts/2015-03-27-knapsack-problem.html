<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Blog1729 - Knapsack problem</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
	<script type="text/x-mathjax-config">
	  MathJax.Hub.Config({
	  tex2jax: {
	  inlineMath: [ ['$','$'], ["\\(","\\)"] ],
	  displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
	  processEscapes: true
	  },
	  TeX: {
	  Macros: {
	  R: "\\mathbb{R}",
	  C: "\\mathbb{C}"
	  }}	  
	  });
	</script>
	<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Blog1729</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Knapsack problem</h1>

            <div class="info">
    Posted on March 27, 2015
    
</div>

<p>There are two forms of the Knapsack problem, one is the <span class="math inline">\(0-1\)</span> knapsack problem and fractional knapsack problem. The <span class="math inline">\(0-1\)</span> knapsack problem is a widely used counter-example that the greedy strategy wouldnâ€™t always work, while the fractional knapsack problem has a greedy solution.</p>
<h2 id="knapsack-problem"><span class="math inline">\(0-1\)</span> Knapsack problem</h2>
<p>There are <span class="math inline">\(n\)</span> items and the <span class="math inline">\(i\)</span>th item is worth <span class="math inline">\(v_i\)</span> dollars and weights <span class="math inline">\(w_i\)</span> pounds (<span class="math inline">\(v_i\)</span> and <span class="math inline">\(w_i\)</span> are integers). You cannot carry more than <span class="math inline">\(W\)</span> weight in the Knapsack, where <span class="math inline">\(W\)</span> is also an integer. The problem is to find out what items one should take.</p>
<p>One can use dynamic programming to solve the <span class="math inline">\(0-1\)</span> Knapsack problem and also construct an easy counterexample to show that the greedy strategy can fail in this case. The dynamic programming algorithm takes <span class="math inline">\(O(nW)\)</span> time.</p>
<h2 id="fractional-knapsack-problem">Fractional Knapsack problem</h2>
<p>The setup for this is the same as <span class="math inline">\(0-1\)</span> Knapsack problem, but in this case we can take a fraction of the item too.</p>
<h3 id="algorithm">Algorithm</h3>
<p>The algorithm is as follows</p>
<ul>
<li>Find <span class="math inline">\(v_i/W_i\)</span> for every item and pick the maximum amount that can be taken for the element with highest value of the ratio.</li>
<li>If we can carry more weight, repeat the process for the remaining elements, otherwise stop.</li>
</ul>
<p>The above algorithm is, of course, greedy (this algorithm fails for the <span class="math inline">\(0-1\)</span> knapsack problem). The running time of the algorithm is <span class="math inline">\(\mathcal O (n^2)\)</span>.</p>
<h2 id="notes">Notes</h2>
<ul>
<li>By fusing with the strategy we used for quick sort, we can improve the running time of the fractional Knapsack problem to <span class="math inline">\(\mathcal O(n)\)</span>. (See the following <a href="http://cs.stackexchange.com/questions/11620/fractional-knapsack-in-linear-time">Computer Science beta StackExchange discussion</a>).</li>
<li>Given a set of points <span class="math inline">\(\{x_1, \cdots, x_n\}\)</span> on real line, to determine the smallest set of unit-length close intervals that contains all of the given points, we can use the following method:</li>
<li>Find the minimum out of all the points, call is <span class="math inline">\(z\)</span>.</li>
<li>Consider the closed interval <span class="math inline">\([z, z+1]\)</span>, remove all the points in <span class="math inline">\(\{x_1, \cdots, x_n\}\)</span> that belong to this closed interval and call the set <span class="math inline">\(S\)</span>.</li>
<li>Repeat the same process to <span class="math inline">\(S\)</span> until <span class="math inline">\(S\)</span> becomes empty.</li>
</ul>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
